// Generated by CoffeeScript 1.6.2
(function() {
  var connect, createRoutingProxy, fs, http, httpProxy, mime, patchServerResponseForRedirects, server, utils;

  connect = require('connect');

  mime = require('connect')["static"].mime;

  http = require('http');

  fs = require('fs');

  utils = require('./utils');

  httpProxy = require('http-proxy');

  server = {};

  server.start = function(hem, options) {
    var app;

    app = connect();
    app.use(server.middleware(hem, options));
    return http.createServer(app).listen(options.port, options.host);
  };

  server.middleware = function(hem, options) {
    var hemapp, pkg, route, statics, value, _i, _j, _len, _len1, _ref, _ref1, _ref2;

    _ref = hem.apps;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      hemapp = _ref[_i];
      utils.info("> Apply route mappings for application: <green>" + hemapp.name + "</green>");
      _ref1 = hemapp.packages;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        pkg = _ref1[_j];
        utils.info("- Mapping route  <yellow>" + pkg.route + "</yellow> to <yellow>" + pkg.target + "</yellow>");
      }
      if (hemapp["static"]) {
        options.routes = utils.extend(hemapp["static"], options.routes);
      }
    }
    statics = connect();
    _ref2 = options.routes;
    for (route in _ref2) {
      value = _ref2[route];
      if (typeof value === 'string') {
        if (fs.existsSync(value)) {
          utils.info("- Mapping static <yellow>" + route + "</yellow> to <yellow>" + value + "</yellow>");
          statics.use(route, connect["static"](value));
        } else {
          utils.errorAndExit("The folder " + value + " does not exist.");
        }
      } else if (value.host) {
        utils.info("- Proxy requests <yellow>" + route + "</yellow> to <yellow>" + value.host + ":" + (value.port || 80) + value.hostPath + "</yellow>");
        statics.use(route, createRoutingProxy(value));
      } else {
        utils.errorAndExit("Invalid route configuration for <yellow>" + route + "</yellow>");
      }
    }
    return function(req, res, next) {
      var str, url, _k, _len2, _ref3, _ref4;

      url = ((_ref3 = require("url").parse(req.url)) != null ? _ref3.pathname.toLowerCase() : void 0) || "";
      if (url.match(/\.js|\.css/)) {
        _ref4 = hem.apps;
        for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
          hemapp = _ref4[_k];
          if (pkg = hemapp.isMatchingRoute(url)) {
            str = pkg.build(false);
            res.charset = 'utf-8';
            res.setHeader('Content-Type', mime.lookup(pkg.target));
            res.setHeader('Content-Length', Buffer.byteLength(str));
            res.end((req.method === 'HEAD' && null) || str);
            return;
          }
        }
      }
      return statics.handle(req, res, next);
    };
  };

  createRoutingProxy = function(options) {
    var proxy;

    if (options == null) {
      options = {};
    }
    proxy = new httpProxy.RoutingProxy();
    options.hostPath || (options.hostPath = "");
    options.port || (options.port = 80);
    options.patchRedirect || (options.patchRedirect = true);
    if (options.patchRedirect) {
      proxy.once("start", function(req, res) {
        var returnHost;

        returnHost = req.headers.host;
        return patchServerResponseForRedirects(options.host, returnHost);
      });
    }
    return function(req, res, next) {
      req.url = "" + options.hostPath + req.url;
      return proxy.proxyRequest(req, res, options);
    };
  };

  patchServerResponseForRedirects = function(fromHost, returnHost) {
    var writeHead;

    writeHead = http.ServerResponse.prototype.writeHead;
    return http.ServerResponse.prototype.writeHead = function(status) {
      var headers, newLocation, oldLocation;

      if (status === 301 || status === 302) {
        headers = this._headers;
        oldLocation = new RegExp(":\/\/" + fromHost + ":?[0-9]*");
        newLocation = "://" + returnHost;
        headers.location = headers.location.replace(oldLocation, newLocation);
      }
      return writeHead.apply(this, arguments);
    };
  };

  module.exports = server;

}).call(this);
