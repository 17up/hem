// Generated by CoffeeScript 1.6.2
(function() {
  var connect, createRoutingProxy, determineUrlFromRoutes, fs, http, httpProxy, patchServerResponseForRedirects, server;

  connect = require('connect');

  httpProxy = require('http-proxy');

  http = require('http');

  fs = require('fs');

  server = {};

  server.start = function(packages, options) {
    var app;

    app = connect();
    app.use(server.middleware(app, packages, options));
    return http.createServer(app).listen(options.port, options.host);
  };

  server.middleware = function(app, packages, options) {
    var pkg, route, url, value, _i, _j, _len, _len1, _ref;

    for (_i = 0, _len = packages.length; _i < _len; _i++) {
      pkg = packages[_i];
      pkg.url || (pkg.url = determineUrlFromRoutes(pkg, options.routes));
      if (!pkg.url) {
        throw new Error("Unable to determine url mapping for package: " + pkg.name);
      }
      if (!!server.VERBOSE) {
        console.log("Map package '" + pkg.name + "' to " + pkg.url);
      }
    }
    _ref = options.routes;
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      route = _ref[_j];
      url = Object.keys(route)[0];
      value = route[url];
      if (typeof value === 'string') {
        if (fs.existsSync(value)) {
          if (!!server.VERBOSE) {
            console.log("Map directory '" + value + "' to " + url);
          }
          app.use(url, connect["static"](value));
        } else {
          console.log("ERROR: The folder " + value + " does not exist.");
          process.exit(1);
        }
      } else if (value.host) {
        if (!!server.VERBOSE) {
          console.log("Proxy requests from " + url + " to " + value.host);
        }
        app.use(url, createRoutingProxy(value));
      } else {
        throw new Error("Invalid route configuration for " + url);
      }
    }
    return function(req, res, next) {
      var str, _k, _len2, _ref1;

      url = ((_ref1 = require("url").parse(req.url)) != null ? _ref1.pathname.toLowerCase() : void 0) || "";
      if (url.match(/\.js|\.css/)) {
        for (_k = 0, _len2 = packages.length; _k < _len2; _k++) {
          pkg = packages[_k];
          if (url === pkg.url) {
            str = pkg.compile(!!server.DEBUG);
            res.charset = 'utf-8';
            res.setHeader('Content-Type', pkg.contentType);
            res.setHeader('Content-Length', Buffer.byteLength(str));
            res.end((req.method === 'HEAD' && null) || str);
            return;
          }
        }
      }
      return next();
    };
  };

  createRoutingProxy = function(options) {
    var proxy;

    if (options == null) {
      options = {};
    }
    proxy = new httpProxy.RoutingProxy();
    options.hostPath || (options.hostPath = "");
    options.port || (options.port = 80);
    options.patchRedirect || (options.patchRedirect = true);
    if (options.patchRedirect) {
      proxy.once("start", function(req, res) {
        var returnHost;

        returnHost = req.headers.host;
        return patchServerResponseForRedirects(options.host, returnHost);
      });
    }
    return function(req, res, next) {
      req.url = "" + options.hostPath + req.url;
      return proxy.proxyRequest(req, res, options);
    };
  };

  patchServerResponseForRedirects = function(fromHost, returnHost) {
    var writeHead;

    writeHead = http.ServerResponse.prototype.writeHead;
    return http.ServerResponse.prototype.writeHead = function(status) {
      var headers, newLocation, oldLocation;

      if (status === 301 || status === 302) {
        headers = this._headers;
        oldLocation = new RegExp(":\/\/" + fromHost + ":?[0-9]*");
        newLocation = "://" + returnHost;
        headers.location = headers.location.replace(oldLocation, newLocation);
      }
      return writeHead.apply(this, arguments);
    };
  };

  determineUrlFromRoutes = function(pkg, routes) {
    var bestMatch, dir, route, url, _i, _len;

    bestMatch = {};
    for (_i = 0, _len = routes.length; _i < _len; _i++) {
      route = routes[_i];
      url = Object.keys(route);
      dir = route[url];
      if (pkg.target.indexOf(dir) === 0 && (!bestMatch.url || bestMatch.dir.length < dir.length)) {
        bestMatch.url = url + pkg.target.slice(dir.length);
        bestMatch.dir = dir;
      }
    }
    return bestMatch.url.toLowerCase();
  };

  module.exports = server;

}).call(this);
